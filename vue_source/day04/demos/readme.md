# 发布订阅模式
任务

- 作业
- 代理方法（app.name, app._data.name）
- 事件模型（node: event模块）
- vue 中 Observer 与 Watcher 和 Dep

代理方法：就是要将app._data中的成员给映射到app上

由于需要在更新数据的时候，更新页面的内容。
**所以app._data访问的成员，与app访问的成员应该是同一个成员**

由于app._data已经是响应式的对象了，所以只需要让app访问的成员去访问app._data的对象成员就可以了。

例如：
```js
app.name 转换为 app._data.name
app.XXX 转换为 app._data.XXX
```
引入了一个自定义函数proxy(target, src, prop)，将target的操作映射到src.prop上。
这里是因为当时没有`Proxy`语法（es6）

我们之前处理的reactify方法不行了，我们需要一个新的方法来处理
提供一个Observer的方法，在方法中对属性进行处理；可以将这个方法封装发到initData方法中



## 解释 proxy
p10


# 发布订阅模式
目标：解耦，让各个模块之间没有强联系

现在的处理方法是：属性在更新的时候，调用 mountComponent 方法

问题：mountComponent更新的时候什么？（现在的例子）全部的页面 => 当前虚拟DOM对应的页面DOM
在Vue中，整个的更新是按照组件为单位进行**判断**，以节点为单位进行更新

- 如果代码中没有自定义组件，在比较算法的时候，我们会将全部的模板对应的虚拟DOM进行比较。
- 如果代码中含有自定义组件，那么在比较算法的时候，就会判断更新的是哪一些组件中的属性，只会判断更新数据的组件，其他组件不会更新。

复杂的页面是有很多组件构成的，每一个属性要更新的时候都要调用 更新的方法。

**目标：如果修改了什么属性，就尽可能只更新哪些属性对应的页面DOM**

例子：
双十一的时候，有一款热销商品，没有现货，但是我又很想要。于是我跟老板之间达成一个协议：如果有货了，你就通知我下单。在这个场景中：

老板就是发布者，订阅的这个东西就是中间媒介，
我就是订阅者。


使用代码的结构来描述：
- 1、老板提供一个帐单列表（数组）
- 2、我可以跟你需求订阅我的商品（老板记录下谁定了什么东西，在数组中存储某些东西）
- 3、等待，可以做其他事情
- 4、当货品来到的时候，老板就查看账单列表，挨个发信息通知(遍历数组，取出数组的元素来使用)

实际上这就是事件模型

- 1、有一个event对象
- 2、on,off,emit方法

实现事件模型，思考怎么使用？

- 1、event是一个全局对象
- 2、event.on('事件名', 处理函数)，订阅事件
    - 1、事件可以连续订阅
    - 2、可以移除：event.off(), 
        - 1、移除所有
        - 2、移除某一个类型的事件
        - 3、移除某一个类型的某一个处理函数
- 3、写别的代码
- 4、event.emit('事件名', 参数) 先前注册的事件处理函数会依次调用


## 发布订阅模式（形式不局限于函数，形式可以使对象等）
- 1、中间的**全局容器**，用来**存储**可以被触发的东西（函数、对象）
- 2、一个方法，可以往容器中**传入**东西
- 3、需要一个方法，可以将容器中的东西取出来**使用**(函数调用，对象的方法调用)

## Vue模型

页面中的变更(diff算法)，是以组件为单位变更的

- 如果页面汇总只有一个组件（一个watcher），不会有性能损失
- 但是如果页面中有多个组件（多watcher的一种情况），每一次会有多个watcher存入到全局watcher中。
    - 如果修改了局部的数据（例如其中一个组件的数据，），表示只会对该组件进行diff算法，也就是说只会重新生成该组件的抽象语法树，只会访问该组件的watcher，也就表示再次往全局存储的只有该组件的watcher。
    - 页面更新的时候，也就只会更新一部分。


