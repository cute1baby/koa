【这部分没有理解好=======>>>>>>>>】
先将函数做分离处理。

# 改写observer函数
缺陷：
- 无法处理数组
- 响应式无法在中间集成watcher处理
- 我们实现的reactify需要和实例紧紧地绑定在一起。分离（解耦）


## 问题
- observer 还没对单独的数组元素做处理，这里需要进行改写。

## 引入Watcher

问题：
- 模型（图）
- 关于this的问题

实现：

分成2步：
- 1、只考虑修改后刷新（响应式）
- 2、在考虑依赖收集（优化）

在Vue中提供一个构造函数Watcher
Watcher会有一些方法：
- get()用来进行**计算**或**执行**处理函数
- update()公共的外部方法，该方法会触发内部的run方法
- run()运行，用来判断内部是使用异步运行还是同步运行等，这个方法最终会调用内部的get方法
- cleanupDep()简单地理解为清除队列

我们的页面渲染是上面的那一个方法执行的呢？？？get方法

我们的watcher实例有一个属性vm，表示的就是当前的vue实例


# 引入Dep对象
该对象提供 依赖收集（depend）的功能，和派发更新（notify）的功能

在notify中去调用 watcher 和 update 方法

# Watcher 与 Dep
之前将 渲染Watcher 放在全局作用域上，这样处理是有问题的。

- vue项目中包含很多的组件，各个组件都是**自治**
    - 那么 watcher 就可以会有多个
    - 每一个 watcher 用于描述一个渲染行为 或者 计算行为
        - 子组件发生数据的更新，页面需要重新渲染（真正的Vue中是局部渲染）
        - 例如 vue 中推荐的是使用 计算属性 代替复杂的 插值表达式(比如在模板中的三元运算符)
            - 计算属性是会伴随其使用的属性的变化而变化的
            - `name: () => this.firstName + this.lastName`
                - 计算属性 依赖于 firstName 和 属性 lastName
                - 只要被依赖的属性发生变化，那么就会促使计算属性 **重新计算**（watcher）

- 依赖收集和派发更新是怎么联系起来的
**我们在访问的时候 就会进行收集，在修改的时候就会更新，那么收集什么就更新什么**

所谓的依赖收集，**实际上就是告诉当前的watcher什么属性被访问了**，那么在这个watcher计算的时候 或者 渲染页面的时候，就会将这些收集到的属性进行更新。

如何将 属性 和当前的watcher关联起来？？
- 在全局准备一个targetStack(watcher栈，简单的理解为watcher数组，把一个操作中需要使用的watcher都收集起来)
- 在Watcher 调用get 方法的时候，将当前Watcher放到全局，在get执行结束的时候(之后)，将这个全局的watcher移除。提供两个方法：pushTarget,popTarget
- 在每一个属性中都有一个Dep对象

**每个data中被响应式的属性都有一个watcher**

我们在访问对象属性的时候（get）,我们的渲染watcher就在全局中。将属性与watcher关联，其实就是将当前渲染的watcher存储到属性相关的dep中。
同时，将dep也存储到 当前全局的watcher中（互相引用的关系）

- 属性引用了当前的渲染 watcher, **属性知道谁渲染它**
- 当前渲染 watcher 引用了 访问的属性（Dep）,**当前的Watcher知道渲染了什么属性**

我们的 dep 有一个方法，叫做notify()
内部就是将 dep 中的 subs 取出来，依次调用其update方法

而subs中存储的是**知道要渲染什么属性的 watcher**